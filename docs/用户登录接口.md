æˆ‘æ¥å¸®ä½ è®¾è®¡ç”¨æˆ·ç™»å½•çš„æ¥å£å’Œåº“è¡¨è®¾è®¡ï¼š

## ğŸ—„ï¸ ç”¨æˆ·è¡¨è®¾è®¡

### 1. ç”¨æˆ·è¡¨ç»“æ„

```sql
CREATE TABLE users (
    user_id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'ç”¨æˆ·ID',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT 'ç”¨æˆ·å',
    email VARCHAR(100) UNIQUE COMMENT 'é‚®ç®±',
    password_hash VARCHAR(255) NOT NULL COMMENT 'å¯†ç å“ˆå¸Œ',
    full_name VARCHAR(100) COMMENT 'çœŸå®å§“å',
    role ENUM('admin', 'doctor', 'researcher', 'viewer') DEFAULT 'doctor' COMMENT 'ç”¨æˆ·è§’è‰²',
    department VARCHAR(100) COMMENT 'æ‰€å±éƒ¨é—¨',
    avatar_url VARCHAR(500) COMMENT 'å¤´åƒURL',
    phone VARCHAR(20) COMMENT 'æ‰‹æœºå·',
    is_active TINYINT DEFAULT 1 COMMENT 'æ˜¯å¦æ¿€æ´»(0-ç¦ç”¨,1-å¯ç”¨)',
    last_login DATETIME COMMENT 'æœ€åç™»å½•æ—¶é—´',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'æ›´æ–°æ—¶é—´',
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_role (role)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ç”¨æˆ·è¡¨';

-- ç”¨æˆ·ç™»å½•æ—¥å¿—è¡¨
CREATE TABLE login_logs (
    log_id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'æ—¥å¿—ID',
    user_id INT NOT NULL COMMENT 'ç”¨æˆ·ID',
    login_ip VARCHAR(45) COMMENT 'ç™»å½•IP',
    user_agent TEXT COMMENT 'ç”¨æˆ·ä»£ç†',
    login_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT 'ç™»å½•æ—¶é—´',
    status ENUM('success', 'failed') COMMENT 'ç™»å½•çŠ¶æ€',
    failure_reason VARCHAR(200) COMMENT 'å¤±è´¥åŸå› ',
    INDEX idx_user_id (user_id),
    INDEX idx_login_time (login_time),
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ç™»å½•æ—¥å¿—è¡¨';
```

### 2. æ’å…¥æµ‹è¯•æ•°æ®

```sql
-- æ’å…¥æµ‹è¯•ç”¨æˆ· (å¯†ç éƒ½æ˜¯: 123456)
INSERT INTO users (username, email, password_hash, full_name, role, department) VALUES 
('admin', 'admin@hospital.com', '$2b$12$LQv3c1yqBWVHxkd0L8k7esd8dQQC5eRYtsj4C1BfqgSGcV7C2lL5a', 'ç³»ç»Ÿç®¡ç†å‘˜', 'admin', 'ä¿¡æ¯ç§‘'),
('dr_wang', 'wang@hospital.com', '$2b$12$LQv3c1yqBWVHxkd0L8k7esd8dQQC5eRYtsj4C1BfqgSGcV7C2lL5a', 'ç‹åŒ»ç”Ÿ', 'doctor', 'å‘¼å¸ç§‘'),
('dr_li', 'li@hospital.com', '$2b$12$LQv3c1yqBWVHxkd0L8k7esd8dQQC5eRYtsj4C1BfqgSGcV7C2lL5a', 'æç ”ç©¶å‘˜', 'researcher', 'ç§‘ç ”éƒ¨'),
('viewer_zhang', 'zhang@hospital.com', '$2b$12$LQv3c1yqBWVHxkd0L8k7esd8dQQC5eRYtsj4C1BfqgSGcV7C2lL5a', 'å¼ åŒ»ç”Ÿ', 'viewer', 'æ”¾å°„ç§‘');
```

## ğŸ” è®¤è¯ç›¸å…³ä¾èµ–

### æ›´æ–° `requirements.txt`

```txt
# æ·»åŠ è®¤è¯ç›¸å…³ä¾èµ–
flask-jwt-extended==4.5.3
pyjwt==2.8.0
bcrypt==4.1.2
python-dotenv==1.0.0
```

## ğŸ—ï¸ è®¤è¯ç³»ç»Ÿå®ç°

### 1. ç”¨æˆ·æ•°æ®æ¨¡å‹ `app/models/user.py`

```python
from app import db
from datetime import datetime
import bcrypt
import jwt
from flask import current_app

class User(db.Model):
    __tablename__ = 'users'
    
    user_id = db.Column(db.Integer, primary_key=True, comment='ç”¨æˆ·ID')
    username = db.Column(db.String(50), unique=True, nullable=False, comment='ç”¨æˆ·å')
    email = db.Column(db.String(100), unique=True, comment='é‚®ç®±')
    password_hash = db.Column(db.String(255), nullable=False, comment='å¯†ç å“ˆå¸Œ')
    full_name = db.Column(db.String(100), comment='çœŸå®å§“å')
    role = db.Column(db.String(20), default='doctor', comment='ç”¨æˆ·è§’è‰²')
    department = db.Column(db.String(100), comment='æ‰€å±éƒ¨é—¨')
    avatar_url = db.Column(db.String(500), comment='å¤´åƒURL')
    phone = db.Column(db.String(20), comment='æ‰‹æœºå·')
    is_active = db.Column(db.Boolean, default=True, comment='æ˜¯å¦æ¿€æ´»')
    last_login = db.Column(db.DateTime, comment='æœ€åç™»å½•æ—¶é—´')
    created_time = db.Column(db.DateTime, default=datetime.utcnow, comment='åˆ›å»ºæ—¶é—´')
    updated_time = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, comment='æ›´æ–°æ—¶é—´')
    
    def set_password(self, password):
        """è®¾ç½®å¯†ç """
        salt = bcrypt.gensalt()
        self.password_hash = bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')
    
    def check_password(self, password):
        """éªŒè¯å¯†ç """
        return bcrypt.checkpw(password.encode('utf-8'), self.password_hash.encode('utf-8'))
    
    def generate_token(self):
        """ç”ŸæˆJWT token"""
        payload = {
            'user_id': self.user_id,
            'username': self.username,
            'role': self.role,
            'exp': datetime.utcnow() + current_app.config['JWT_ACCESS_TOKEN_EXPIRES']
        }
        return jwt.encode(payload, current_app.config['JWT_SECRET_KEY'], algorithm='HS256')
    
    def to_dict(self):
        """è½¬æ¢ä¸ºå­—å…¸æ ¼å¼"""
        return {
            'user_id': self.user_id,
            'username': self.username,
            'email': self.email,
            'full_name': self.full_name,
            'role': self.role,
            'department': self.department,
            'avatar_url': self.avatar_url,
            'phone': self.phone,
            'is_active': self.is_active,
            'last_login': self.last_login.isoformat() if self.last_login else None,
            'created_time': self.created_time.isoformat() if self.created_time else None
        }
    
    def __repr__(self):
        return f'<User {self.username}>'

class LoginLog(db.Model):
    __tablename__ = 'login_logs'
    
    log_id = db.Column(db.Integer, primary_key=True, comment='æ—¥å¿—ID')
    user_id = db.Column(db.Integer, db.ForeignKey('users.user_id'), nullable=False, comment='ç”¨æˆ·ID')
    login_ip = db.Column(db.String(45), comment='ç™»å½•IP')
    user_agent = db.Column(db.Text, comment='ç”¨æˆ·ä»£ç†')
    login_time = db.Column(db.DateTime, default=datetime.utcnow, comment='ç™»å½•æ—¶é—´')
    status = db.Column(db.String(20), comment='ç™»å½•çŠ¶æ€')
    failure_reason = db.Column(db.String(200), comment='å¤±è´¥åŸå› ')
    
    user = db.relationship('User', backref=db.backref('login_logs', lazy=True))
    
    def to_dict(self):
        return {
            'log_id': self.log_id,
            'user_id': self.user_id,
            'login_ip': self.login_ip,
            'user_agent': self.user_agent,
            'login_time': self.login_time.isoformat() if self.login_time else None,
            'status': self.status,
            'failure_reason': self.failure_reason
        }
```

### 2. è®¤è¯å·¥å…·ç±» `app/utils/auth.py`

```python
import jwt
from flask import request, current_app
from functools import wraps
from app.models.user import User
from app.utils.response import error

def token_required(f):
    """JWT tokenéªŒè¯è£…é¥°å™¨"""
    @wraps(f)
    def decorated(*args, **kwargs):
        token = None
        
        # ä»headerè·å–token
        if 'Authorization' in request.headers:
            auth_header = request.headers['Authorization']
            try:
                token = auth_header.split(" ")[1]  # Bearer <token>
            except IndexError:
                return error('Invalid token format'), 401
        
        if not token:
            return error('Token is missing'), 401
        
        try:
            # è§£ç token
            data = jwt.decode(token, current_app.config['JWT_SECRET_KEY'], algorithms=['HS256'])
            current_user = User.query.get(data['user_id'])
            
            if not current_user or not current_user.is_active:
                return error('User not found or inactive'), 401
                
        except jwt.ExpiredSignatureError:
            return error('Token has expired'), 401
        except jwt.InvalidTokenError:
            return error('Invalid token'), 401
        except Exception as e:
            return error('Token verification failed'), 401
        
        return f(current_user, *args, **kwargs)
    
    return decorated

def roles_required(*roles):
    """è§’è‰²æƒé™éªŒè¯è£…é¥°å™¨"""
    def decorator(f):
        @wraps(f)
        @token_required
        def decorated(current_user, *args, **kwargs):
            if current_user.role not in roles:
                return error('Insufficient permissions'), 403
            return f(current_user, *args, **kwargs)
        return decorated
    return decorator

def get_client_ip():
    """è·å–å®¢æˆ·ç«¯IP"""
    if request.headers.get('X-Forwarded-For'):
        return request.headers.get('X-Forwarded-For').split(',')[0]
    elif request.headers.get('X-Real-IP'):
        return request.headers.get('X-Real-IP')
    else:
        return request.remote_addr
```

### 3. è®¤è¯è·¯ç”± `app/routes/auth_routes.py`

```python
from flask import Blueprint, request, jsonify
from app import db
from app.models.user import User, LoginLog
from app.utils.auth import get_client_ip
from app.utils.response import success, error
from datetime import datetime

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/login', methods=['POST'])
def login():
    """ç”¨æˆ·ç™»å½•"""
    try:
        data = request.json
        
        # å‚æ•°éªŒè¯
        if not data or 'username' not in data or 'password' not in data:
            return error('Username and password are required'), 400
        
        username = data['username'].strip()
        password = data['password']
        
        # æŸ¥æ‰¾ç”¨æˆ·
        user = User.query.filter_by(username=username).first()
        
        # è®°å½•ç™»å½•å°è¯•
        login_log = LoginLog(
            user_id=user.user_id if user else None,
            login_ip=get_client_ip(),
            user_agent=request.headers.get('User-Agent'),
            status='failed',
            failure_reason='User not found' if not user else None
        )
        
        if not user:
            db.session.add(login_log)
            db.session.commit()
            return error('Invalid username or password'), 401
        
        if not user.is_active:
            login_log.failure_reason = 'User inactive'
            db.session.add(login_log)
            db.session.commit()
            return error('Account is disabled'), 401
        
        # éªŒè¯å¯†ç 
        if not user.check_password(password):
            login_log.failure_reason = 'Invalid password'
            db.session.add(login_log)
            db.session.commit()
            return error('Invalid username or password'), 401
        
        # ç™»å½•æˆåŠŸ
        user.last_login = datetime.utcnow()
        
        login_log.status = 'success'
        login_log.failure_reason = None
        db.session.add(login_log)
        db.session.commit()
        
        # ç”Ÿæˆtoken
        token = user.generate_token()
        
        return success({
            'message': 'Login successful',
            'token': token,
            'user': user.to_dict()
        })
        
    except Exception as e:
        db.session.rollback()
        return error(f'Login failed: {str(e)}'), 500

@auth_bp.route('/register', methods=['POST'])
def register():
    """ç”¨æˆ·æ³¨å†Œï¼ˆä»…ç®¡ç†å‘˜å¯åˆ›å»ºç”¨æˆ·ï¼‰"""
    try:
        data = request.json
        
        # å¿…å¡«å­—æ®µéªŒè¯
        required_fields = ['username', 'password', 'email', 'full_name']
        for field in required_fields:
            if not data.get(field):
                return error(f'Field {field} is required'), 400
        
        # æ£€æŸ¥ç”¨æˆ·åå’Œé‚®ç®±æ˜¯å¦å·²å­˜åœ¨
        if User.query.filter_by(username=data['username']).first():
            return error('Username already exists'), 400
        
        if User.query.filter_by(email=data['email']).first():
            return error('Email already exists'), 400
        
        # åˆ›å»ºæ–°ç”¨æˆ·
        new_user = User(
            username=data['username'],
            email=data['email'],
            full_name=data['full_name'],
            role=data.get('role', 'doctor'),
            department=data.get('department'),
            phone=data.get('phone')
        )
        
        new_user.set_password(data['password'])
        
        db.session.add(new_user)
        db.session.commit()
        
        return success({
            'message': 'User registered successfully',
            'user': new_user.to_dict()
        })
        
    except Exception as e:
        db.session.rollback()
        return error(f'Registration failed: {str(e)}'), 500

@auth_bp.route('/profile', methods=['GET'])
@token_required
def get_profile(current_user):
    """è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯"""
    return success({'user': current_user.to_dict()})

@auth_bp.route('/profile', methods=['PUT'])
@token_required
def update_profile(current_user):
    """æ›´æ–°ç”¨æˆ·ä¿¡æ¯"""
    try:
        data = request.json
        
        updatable_fields = ['full_name', 'email', 'department', 'phone', 'avatar_url']
        
        for field in updatable_fields:
            if field in data:
                setattr(current_user, field, data[field])
        
        # å¦‚æœä¿®æ”¹å¯†ç 
        if 'password' in data and data['password']:
            current_user.set_password(data['password'])
        
        db.session.commit()
        
        return success({
            'message': 'Profile updated successfully',
            'user': current_user.to_dict()
        })
        
    except Exception as e:
        db.session.rollback()
        return error(f'Profile update failed: {str(e)}'), 500

@auth_bp.route('/logout', methods=['POST'])
@token_required
def logout(current_user):
    """ç”¨æˆ·ç™»å‡º"""
    # JWTæ˜¯æ— çŠ¶æ€çš„ï¼Œå®¢æˆ·ç«¯åˆ é™¤tokenå³å¯
    # è¿™é‡Œå¯ä»¥è®°å½•ç™»å‡ºæ—¥å¿—æˆ–åŠ å…¥é»‘åå•ï¼ˆå¦‚æœéœ€è¦ï¼‰
    return success({'message': 'Logout successful'})

@auth_bp.route('/users', methods=['GET'])
@token_required
@roles_required('admin')
def get_users(current_user):
    """è·å–ç”¨æˆ·åˆ—è¡¨ï¼ˆä»…ç®¡ç†å‘˜ï¼‰"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)
        role = request.args.get('role', '')
        search = request.args.get('search', '')
        
        query = User.query
        
        if role:
            query = query.filter(User.role == role)
        
        if search:
            query = query.filter(
                db.or_(
                    User.username.like(f'%{search}%'),
                    User.full_name.like(f'%{search}%'),
                    User.email.like(f'%{search}%')
                )
            )
        
        pagination = query.order_by(User.created_time.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        users_data = {
            'items': [user.to_dict() for user in pagination.items],
            'pagination': {
                'total': pagination.total,
                'page': page,
                'per_page': per_page,
                'pages': pagination.pages
            }
        }
        
        return success(users_data)
        
    except Exception as e:
        return error(f'Failed to fetch users: {str(e)}'), 500
```

### 4. æ›´æ–°é…ç½®æ–‡ä»¶ `config.py`

```python
import os
from datetime import timedelta

class Config:
    # ... å…¶ä»–é…ç½®ä¿æŒä¸å˜ ...
    
    # JWTé…ç½®
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY') or 'your-super-secret-jwt-key-change-in-production'
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=24)
    
    # å¯†ç åŠ å¯†é…ç½®
    BCRYPT_LOG_ROUNDS = 12
```

### 5. æ›´æ–°åº”ç”¨åˆå§‹åŒ– `app/__init__.py`

```python
def create_app():
    app = Flask(__name__)
    
    # é…ç½®
    app.config.from_object('config.Config')
    
    # åˆå§‹åŒ–æ‰©å±•
    CORS(app)
    db.init_app(app)
    
    # Celeryé…ç½®
    celery.conf.update(
        broker_url=app.config['CELERY_BROKER_URL'],
        result_backend=app.config['CELERY_RESULT_BACKEND']
    )
    
    # æ³¨å†Œè“å›¾
    from app.routes.auth_routes import auth_bp
    from app.routes.data_routes import data_bp
    from app.routes.model_routes import model_bp
    from app.routes.diagnosis_routes import diagnosis_bp
    
    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(data_bp, url_prefix='/api')
    app.register_blueprint(model_bp, url_prefix='/api')
    app.register_blueprint(diagnosis_bp, url_prefix='/api')
    
    # åˆ›å»ºç›®å½•
    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
    os.makedirs(app.config['MODEL_FOLDER'], exist_ok=True)
    
    # åˆå§‹åŒ–æ¨¡å‹
    with app.app_context():
        from app.services.diagnosis_service import init_model
        init_model()
        print("Model initialization completed")
    
    return app
```

## ğŸš€ ä½¿ç”¨ç¤ºä¾‹

### ç™»å½•è¯·æ±‚
```javascript
// ç™»å½•
const login = async (username, password) => {
    const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ username, password })
    });
    return await response.json();
};

// ä½¿ç”¨ç¤ºä¾‹
const result = await login('dr_wang', '123456');
if (result.success) {
    localStorage.setItem('token', result.data.token);
    console.log('ç™»å½•æˆåŠŸ:', result.data.user);
}
```

### å¸¦è®¤è¯çš„APIè°ƒç”¨
```javascript
// è·å–ç”¨æˆ·ä¿¡æ¯
const getProfile = async () => {
    const token = localStorage.getItem('token');
    const response = await fetch('/api/auth/profile', {
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });
    return await response.json();
};

// è·å–æ¨¡å‹åˆ—è¡¨ï¼ˆéœ€è¦ç™»å½•ï¼‰
const getModels = async () => {
    const token = localStorage.getItem('token');
    const response = await fetch('/api/models', {
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });
    return await response.json();
};
```

## ğŸ“‹ APIæ¥å£æ±‡æ€»

| æ–¹æ³• | è·¯å¾„ | è¯´æ˜ | æƒé™ |
|------|------|------|------|
| POST | `/api/auth/login` | ç”¨æˆ·ç™»å½• | å…¬å¼€ |
| POST | `/api/auth/register` | ç”¨æˆ·æ³¨å†Œ | å…¬å¼€ |
| GET | `/api/auth/profile` | è·å–ä¸ªäººä¿¡æ¯ | éœ€ç™»å½• |
| PUT | `/api/auth/profile` | æ›´æ–°ä¸ªäººä¿¡æ¯ | éœ€ç™»å½• |
| POST | `/api/auth/logout` | ç”¨æˆ·ç™»å‡º | éœ€ç™»å½• |
| GET | `/api/auth/users` | è·å–ç”¨æˆ·åˆ—è¡¨ | ä»…ç®¡ç†å‘˜ |

è¿™æ ·ä½ å°±æœ‰äº†å®Œæ•´çš„ç”¨æˆ·è®¤è¯ç³»ç»Ÿï¼Œæ”¯æŒç™»å½•ã€æ³¨å†Œã€æƒé™æ§åˆ¶ç­‰åŠŸèƒ½ï¼
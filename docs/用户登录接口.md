我来帮你设计用户登录的接口和库表设计：

## 🗄️ 用户表设计

### 1. 用户表结构

```sql
CREATE TABLE users (
    user_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    email VARCHAR(100) UNIQUE COMMENT '邮箱',
    password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
    full_name VARCHAR(100) COMMENT '真实姓名',
    role ENUM('admin', 'doctor', 'researcher', 'viewer') DEFAULT 'doctor' COMMENT '用户角色',
    department VARCHAR(100) COMMENT '所属部门',
    avatar_url VARCHAR(500) COMMENT '头像URL',
    phone VARCHAR(20) COMMENT '手机号',
    is_active TINYINT DEFAULT 1 COMMENT '是否激活(0-禁用,1-启用)',
    last_login DATETIME COMMENT '最后登录时间',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_role (role)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户表';

-- 用户登录日志表
CREATE TABLE login_logs (
    log_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '日志ID',
    user_id INT NOT NULL COMMENT '用户ID',
    login_ip VARCHAR(45) COMMENT '登录IP',
    user_agent TEXT COMMENT '用户代理',
    login_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '登录时间',
    status ENUM('success', 'failed') COMMENT '登录状态',
    failure_reason VARCHAR(200) COMMENT '失败原因',
    INDEX idx_user_id (user_id),
    INDEX idx_login_time (login_time),
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='登录日志表';
```

### 2. 插入测试数据

```sql
-- 插入测试用户 (密码都是: 123456)
INSERT INTO users (username, email, password_hash, full_name, role, department) VALUES 
('admin', 'admin@hospital.com', '$2b$12$LQv3c1yqBWVHxkd0L8k7esd8dQQC5eRYtsj4C1BfqgSGcV7C2lL5a', '系统管理员', 'admin', '信息科'),
('dr_wang', 'wang@hospital.com', '$2b$12$LQv3c1yqBWVHxkd0L8k7esd8dQQC5eRYtsj4C1BfqgSGcV7C2lL5a', '王医生', 'doctor', '呼吸科'),
('dr_li', 'li@hospital.com', '$2b$12$LQv3c1yqBWVHxkd0L8k7esd8dQQC5eRYtsj4C1BfqgSGcV7C2lL5a', '李研究员', 'researcher', '科研部'),
('viewer_zhang', 'zhang@hospital.com', '$2b$12$LQv3c1yqBWVHxkd0L8k7esd8dQQC5eRYtsj4C1BfqgSGcV7C2lL5a', '张医生', 'viewer', '放射科');
```

## 🔐 认证相关依赖

### 更新 `requirements.txt`

```txt
# 添加认证相关依赖
flask-jwt-extended==4.5.3
pyjwt==2.8.0
bcrypt==4.1.2
python-dotenv==1.0.0
```

## 🏗️ 认证系统实现

### 1. 用户数据模型 `app/models/user.py`

```python
from app import db
from datetime import datetime
import bcrypt
import jwt
from flask import current_app

class User(db.Model):
    __tablename__ = 'users'
    
    user_id = db.Column(db.Integer, primary_key=True, comment='用户ID')
    username = db.Column(db.String(50), unique=True, nullable=False, comment='用户名')
    email = db.Column(db.String(100), unique=True, comment='邮箱')
    password_hash = db.Column(db.String(255), nullable=False, comment='密码哈希')
    full_name = db.Column(db.String(100), comment='真实姓名')
    role = db.Column(db.String(20), default='doctor', comment='用户角色')
    department = db.Column(db.String(100), comment='所属部门')
    avatar_url = db.Column(db.String(500), comment='头像URL')
    phone = db.Column(db.String(20), comment='手机号')
    is_active = db.Column(db.Boolean, default=True, comment='是否激活')
    last_login = db.Column(db.DateTime, comment='最后登录时间')
    created_time = db.Column(db.DateTime, default=datetime.utcnow, comment='创建时间')
    updated_time = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, comment='更新时间')
    
    def set_password(self, password):
        """设置密码"""
        salt = bcrypt.gensalt()
        self.password_hash = bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')
    
    def check_password(self, password):
        """验证密码"""
        return bcrypt.checkpw(password.encode('utf-8'), self.password_hash.encode('utf-8'))
    
    def generate_token(self):
        """生成JWT token"""
        payload = {
            'user_id': self.user_id,
            'username': self.username,
            'role': self.role,
            'exp': datetime.utcnow() + current_app.config['JWT_ACCESS_TOKEN_EXPIRES']
        }
        return jwt.encode(payload, current_app.config['JWT_SECRET_KEY'], algorithm='HS256')
    
    def to_dict(self):
        """转换为字典格式"""
        return {
            'user_id': self.user_id,
            'username': self.username,
            'email': self.email,
            'full_name': self.full_name,
            'role': self.role,
            'department': self.department,
            'avatar_url': self.avatar_url,
            'phone': self.phone,
            'is_active': self.is_active,
            'last_login': self.last_login.isoformat() if self.last_login else None,
            'created_time': self.created_time.isoformat() if self.created_time else None
        }
    
    def __repr__(self):
        return f'<User {self.username}>'

class LoginLog(db.Model):
    __tablename__ = 'login_logs'
    
    log_id = db.Column(db.Integer, primary_key=True, comment='日志ID')
    user_id = db.Column(db.Integer, db.ForeignKey('users.user_id'), nullable=False, comment='用户ID')
    login_ip = db.Column(db.String(45), comment='登录IP')
    user_agent = db.Column(db.Text, comment='用户代理')
    login_time = db.Column(db.DateTime, default=datetime.utcnow, comment='登录时间')
    status = db.Column(db.String(20), comment='登录状态')
    failure_reason = db.Column(db.String(200), comment='失败原因')
    
    user = db.relationship('User', backref=db.backref('login_logs', lazy=True))
    
    def to_dict(self):
        return {
            'log_id': self.log_id,
            'user_id': self.user_id,
            'login_ip': self.login_ip,
            'user_agent': self.user_agent,
            'login_time': self.login_time.isoformat() if self.login_time else None,
            'status': self.status,
            'failure_reason': self.failure_reason
        }
```

### 2. 认证工具类 `app/utils/auth.py`

```python
import jwt
from flask import request, current_app
from functools import wraps
from app.models.user import User
from app.utils.response import error

def token_required(f):
    """JWT token验证装饰器"""
    @wraps(f)
    def decorated(*args, **kwargs):
        token = None
        
        # 从header获取token
        if 'Authorization' in request.headers:
            auth_header = request.headers['Authorization']
            try:
                token = auth_header.split(" ")[1]  # Bearer <token>
            except IndexError:
                return error('Invalid token format'), 401
        
        if not token:
            return error('Token is missing'), 401
        
        try:
            # 解码token
            data = jwt.decode(token, current_app.config['JWT_SECRET_KEY'], algorithms=['HS256'])
            current_user = User.query.get(data['user_id'])
            
            if not current_user or not current_user.is_active:
                return error('User not found or inactive'), 401
                
        except jwt.ExpiredSignatureError:
            return error('Token has expired'), 401
        except jwt.InvalidTokenError:
            return error('Invalid token'), 401
        except Exception as e:
            return error('Token verification failed'), 401
        
        return f(current_user, *args, **kwargs)
    
    return decorated

def roles_required(*roles):
    """角色权限验证装饰器"""
    def decorator(f):
        @wraps(f)
        @token_required
        def decorated(current_user, *args, **kwargs):
            if current_user.role not in roles:
                return error('Insufficient permissions'), 403
            return f(current_user, *args, **kwargs)
        return decorated
    return decorator

def get_client_ip():
    """获取客户端IP"""
    if request.headers.get('X-Forwarded-For'):
        return request.headers.get('X-Forwarded-For').split(',')[0]
    elif request.headers.get('X-Real-IP'):
        return request.headers.get('X-Real-IP')
    else:
        return request.remote_addr
```

### 3. 认证路由 `app/routes/auth_routes.py`

```python
from flask import Blueprint, request, jsonify
from app import db
from app.models.user import User, LoginLog
from app.utils.auth import get_client_ip
from app.utils.response import success, error
from datetime import datetime

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/login', methods=['POST'])
def login():
    """用户登录"""
    try:
        data = request.json
        
        # 参数验证
        if not data or 'username' not in data or 'password' not in data:
            return error('Username and password are required'), 400
        
        username = data['username'].strip()
        password = data['password']
        
        # 查找用户
        user = User.query.filter_by(username=username).first()
        
        # 记录登录尝试
        login_log = LoginLog(
            user_id=user.user_id if user else None,
            login_ip=get_client_ip(),
            user_agent=request.headers.get('User-Agent'),
            status='failed',
            failure_reason='User not found' if not user else None
        )
        
        if not user:
            db.session.add(login_log)
            db.session.commit()
            return error('Invalid username or password'), 401
        
        if not user.is_active:
            login_log.failure_reason = 'User inactive'
            db.session.add(login_log)
            db.session.commit()
            return error('Account is disabled'), 401
        
        # 验证密码
        if not user.check_password(password):
            login_log.failure_reason = 'Invalid password'
            db.session.add(login_log)
            db.session.commit()
            return error('Invalid username or password'), 401
        
        # 登录成功
        user.last_login = datetime.utcnow()
        
        login_log.status = 'success'
        login_log.failure_reason = None
        db.session.add(login_log)
        db.session.commit()
        
        # 生成token
        token = user.generate_token()
        
        return success({
            'message': 'Login successful',
            'token': token,
            'user': user.to_dict()
        })
        
    except Exception as e:
        db.session.rollback()
        return error(f'Login failed: {str(e)}'), 500

@auth_bp.route('/register', methods=['POST'])
def register():
    """用户注册（仅管理员可创建用户）"""
    try:
        data = request.json
        
        # 必填字段验证
        required_fields = ['username', 'password', 'email', 'full_name']
        for field in required_fields:
            if not data.get(field):
                return error(f'Field {field} is required'), 400
        
        # 检查用户名和邮箱是否已存在
        if User.query.filter_by(username=data['username']).first():
            return error('Username already exists'), 400
        
        if User.query.filter_by(email=data['email']).first():
            return error('Email already exists'), 400
        
        # 创建新用户
        new_user = User(
            username=data['username'],
            email=data['email'],
            full_name=data['full_name'],
            role=data.get('role', 'doctor'),
            department=data.get('department'),
            phone=data.get('phone')
        )
        
        new_user.set_password(data['password'])
        
        db.session.add(new_user)
        db.session.commit()
        
        return success({
            'message': 'User registered successfully',
            'user': new_user.to_dict()
        })
        
    except Exception as e:
        db.session.rollback()
        return error(f'Registration failed: {str(e)}'), 500

@auth_bp.route('/profile', methods=['GET'])
@token_required
def get_profile(current_user):
    """获取当前用户信息"""
    return success({'user': current_user.to_dict()})

@auth_bp.route('/profile', methods=['PUT'])
@token_required
def update_profile(current_user):
    """更新用户信息"""
    try:
        data = request.json
        
        updatable_fields = ['full_name', 'email', 'department', 'phone', 'avatar_url']
        
        for field in updatable_fields:
            if field in data:
                setattr(current_user, field, data[field])
        
        # 如果修改密码
        if 'password' in data and data['password']:
            current_user.set_password(data['password'])
        
        db.session.commit()
        
        return success({
            'message': 'Profile updated successfully',
            'user': current_user.to_dict()
        })
        
    except Exception as e:
        db.session.rollback()
        return error(f'Profile update failed: {str(e)}'), 500

@auth_bp.route('/logout', methods=['POST'])
@token_required
def logout(current_user):
    """用户登出"""
    # JWT是无状态的，客户端删除token即可
    # 这里可以记录登出日志或加入黑名单（如果需要）
    return success({'message': 'Logout successful'})

@auth_bp.route('/users', methods=['GET'])
@token_required
@roles_required('admin')
def get_users(current_user):
    """获取用户列表（仅管理员）"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)
        role = request.args.get('role', '')
        search = request.args.get('search', '')
        
        query = User.query
        
        if role:
            query = query.filter(User.role == role)
        
        if search:
            query = query.filter(
                db.or_(
                    User.username.like(f'%{search}%'),
                    User.full_name.like(f'%{search}%'),
                    User.email.like(f'%{search}%')
                )
            )
        
        pagination = query.order_by(User.created_time.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        users_data = {
            'items': [user.to_dict() for user in pagination.items],
            'pagination': {
                'total': pagination.total,
                'page': page,
                'per_page': per_page,
                'pages': pagination.pages
            }
        }
        
        return success(users_data)
        
    except Exception as e:
        return error(f'Failed to fetch users: {str(e)}'), 500
```

### 4. 更新配置文件 `config.py`

```python
import os
from datetime import timedelta

class Config:
    # ... 其他配置保持不变 ...
    
    # JWT配置
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY') or 'your-super-secret-jwt-key-change-in-production'
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=24)
    
    # 密码加密配置
    BCRYPT_LOG_ROUNDS = 12
```

### 5. 更新应用初始化 `app/__init__.py`

```python
def create_app():
    app = Flask(__name__)
    
    # 配置
    app.config.from_object('config.Config')
    
    # 初始化扩展
    CORS(app)
    db.init_app(app)
    
    # Celery配置
    celery.conf.update(
        broker_url=app.config['CELERY_BROKER_URL'],
        result_backend=app.config['CELERY_RESULT_BACKEND']
    )
    
    # 注册蓝图
    from app.routes.auth_routes import auth_bp
    from app.routes.data_routes import data_bp
    from app.routes.model_routes import model_bp
    from app.routes.diagnosis_routes import diagnosis_bp
    
    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(data_bp, url_prefix='/api')
    app.register_blueprint(model_bp, url_prefix='/api')
    app.register_blueprint(diagnosis_bp, url_prefix='/api')
    
    # 创建目录
    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
    os.makedirs(app.config['MODEL_FOLDER'], exist_ok=True)
    
    # 初始化模型
    with app.app_context():
        from app.services.diagnosis_service import init_model
        init_model()
        print("Model initialization completed")
    
    return app
```

## 🚀 使用示例

### 登录请求
```javascript
// 登录
const login = async (username, password) => {
    const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ username, password })
    });
    return await response.json();
};

// 使用示例
const result = await login('dr_wang', '123456');
if (result.success) {
    localStorage.setItem('token', result.data.token);
    console.log('登录成功:', result.data.user);
}
```

### 带认证的API调用
```javascript
// 获取用户信息
const getProfile = async () => {
    const token = localStorage.getItem('token');
    const response = await fetch('/api/auth/profile', {
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });
    return await response.json();
};

// 获取模型列表（需要登录）
const getModels = async () => {
    const token = localStorage.getItem('token');
    const response = await fetch('/api/models', {
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });
    return await response.json();
};
```

## 📋 API接口汇总

| 方法 | 路径 | 说明 | 权限 |
|------|------|------|------|
| POST | `/api/auth/login` | 用户登录 | 公开 |
| POST | `/api/auth/register` | 用户注册 | 公开 |
| GET | `/api/auth/profile` | 获取个人信息 | 需登录 |
| PUT | `/api/auth/profile` | 更新个人信息 | 需登录 |
| POST | `/api/auth/logout` | 用户登出 | 需登录 |
| GET | `/api/auth/users` | 获取用户列表 | 仅管理员 |

这样你就有了完整的用户认证系统，支持登录、注册、权限控制等功能！
基于您的系统架构，我来设计肺结核诊断辅助功能的接口。这个功能将集成到现有的Flask应用中。

## 接口设计

### 1. 诊断请求接口

**接口路径**: `/api/diagnosis/submit`  
**请求方式**: `POST`  
**Content-Type**: `multipart/form-data`

#### 请求参数

| 参数名              | 类型   | 必填 | 说明           |
| ------------------- | ------ | ---- | -------------- |
| `image`             | file   | 是   | 肺结核影像文件 |
| `clinical_info`     | string | 是   | 临床信息       |
| `patient_name`      | string | 否   | 患者姓名       |
| `patient_gender`    | string | 否   | 患者性别       |
| `patient_age`       | string | 否   | 患者年龄       |
| `medical_record_id` | string | 否   | 病历号         |

#### 请求示例
```python
# 使用requests库调用示例
import requests

files = {
    'image': open('tuberculosis_image.jpg', 'rb')
}
data = {
    'clinical_info': '患者咳嗽、咳痰2周，伴低热、盗汗',
    'patient_name': '张三',
    'patient_gender': '男',
    'patient_age': '45',
    'medical_record_id': 'TB2024001'
}

response = requests.post('http://localhost:5000/api/diagnosis/submit', files=files, data=data)
```

#### 响应体
```json
{
  "code": 200,
  "data": {
    "diagnosis_id": "diag_7ecf0d1efab7",
    "diagnosis_report": "1. 是否患病判断：\n\n根据临床症状（持续咳嗽、低热2周）及影像学表现，患者高度疑似肺结核感染。虽白细胞计数正常，但淋巴细胞比例略高提示可能存在慢性或特异性感染，符合结核病免疫反应特征。综合判断：患者极可能患病，需进一步确诊。\n\n2. 影像描述：\n\n本片为胸部正位X线片，显示双肺野透亮度基本对称，心影大小形态未见明显异常，膈肌轮廓清晰，肋骨及脊柱结构完整。右上肺野可见斑片状模糊密度增高影，边界欠清，局部伴小结节样改变；左肺门区亦可见轻度索条状及斑点状阴影，肺纹理增粗紊乱。双侧肺门无明显肿大，未见胸腔积液或气胸征象。\n\n3. 影像学表现：\n\n- 右上肺野斑片状浸润性阴影，呈“云絮状”或“磨玻璃样”密度，提示活动性炎症渗出。\n- 左肺门区索条影及结节影，提示可能为纤维化灶或淋巴结钙化/反应性增生。\n- 肺纹理增粗、紊乱，符合慢性炎症或结核播散后修复过程。\n- 无空洞、钙化灶或胸膜增厚等典型陈旧性结核征象，提示可能为初发或进展期病变。\n- 病变分布以肺尖及上叶为主，符合肺结核好发部位。\n\n4. 诊断意见：\n\n考虑“活动性肺结核（右上肺为主）”，不排除早期血行播散型或原发综合征可能性。建议结合痰涂片抗酸染色、结核菌素试验（TST）、γ-干扰素释放试验（IGRA）及胸部CT进一步评估病灶性质与范围。\n\n5. 建议：\n\n- 尽快行痰涂片找抗酸杆菌及痰培养，必要时支气管镜灌洗液检查。\n- 行胸部高分辨率CT（HRCT）以明确病灶细节、有无空洞、树芽征或淋巴结受累。\n- 完善结核相关免疫学检测（TST、IGRA）。\n- 若确诊肺结核，应立即启动抗结核治疗并进行传染病上报。\n- 建议隔离观察，避免交叉感染，尤其在儿童或免疫力低下人群中。\n\n报告医师：放射科主治医师 AI助手  \n审核医师：放射科副主任医师 AI助手",
    "pdf_url": "/docs/diagnosis_report_diag_7ecf0d1efab7.pdf",
    "timestamp": "2025-10-21T10:42:31.163037"
  },
  "message": "诊断完成"
}
```

### 2. PDF报告下载接口

**接口路径**: `/api/diagnosis/download/<diagnosis_id>`  
**请求方式**: `GET`

#### 请求参数
路径参数: `diagnosis_id` - 诊断记录ID

#### 响应
- 成功: 返回PDF文件流，Content-Type: `application/pdf`
- 失败: 返回JSON错误信息

### 3. 诊断历史查询接口

**接口路径**: `/api/diagnosis/history`  
**请求方式**: `GET`

#### 查询参数
| 参数名         | 类型   | 必填 | 说明             |
| -------------- | ------ | ---- | ---------------- |
| `page`         | int    | 否   | 页码，默认1      |
| `per_page`     | int    | 否   | 每页数量，默认10 |
| `patient_name` | string | 否   | 患者姓名筛选     |

#### 响应体
```json
{
    "code": 200,
    "message": "查询成功",
    "data": {
        "diagnosis_list": [
            {
                "diagnosis_id": "diag_123456",
                "patient_name": "张三",
                "clinical_info": "患者咳嗽、咳痰2周...",
                "timestamp": "2024-01-20T10:30:00Z",
                "status": "completed"
            }
        ],
        "pagination": {
            "page": 1,
            "per_page": 10,
            "total": 25,
            "pages": 3
        }
    }
}
```

## 实现代码

### 1. 路由文件 `app/routes/diagnosis_routes.py`

```python
from flask import Blueprint, request, jsonify, send_file
from app.services.diagnosis_service import DiagnosisService
from app.utils import ResponseUtil
import io

diagnosis_bp = Blueprint('diagnosis', __name__)

@diagnosis_bp.route('/api/diagnosis/submit', methods=['POST'])
def submit_diagnosis():
    """
    提交诊断请求
    """
    try:
        # 检查文件上传
        if 'image' not in request.files:
            return ResponseUtil.error('没有上传影像文件', code=400)
        
        image_file = request.files['image']
        clinical_info = request.form.get('clinical_info', '').strip()
        
        if image_file.filename == '':
            return ResponseUtil.error('没有选择文件', code=400)
        
        if not clinical_info:
            return ResponseUtil.error('临床信息不能为空', code=400)
        
        # 收集患者信息
        patient_info = {
            'name': request.form.get('patient_name', '').strip(),
            'gender': request.form.get('patient_gender', '').strip(),
            'age': request.form.get('patient_age', '').strip(),
            'medical_record_id': request.form.get('medical_record_id', '').strip()
        }
        
        # 调用诊断服务
        result = DiagnosisService.process_diagnosis(
            image_file=image_file,
            clinical_info=clinical_info,
            patient_info=patient_info
        )
        
        return ResponseUtil.success(
            message='诊断完成',
            data=result
        )
        
    except Exception as e:
        return ResponseUtil.error(f'诊断处理失败: {str(e)}', code=500)

@diagnosis_bp.route('/api/diagnosis/download/<diagnosis_id>', methods=['GET'])
def download_report(diagnosis_id):
    """
    下载诊断报告PDF
    """
    try:
        pdf_buffer = DiagnosisService.get_diagnosis_pdf(diagnosis_id)
        
        if not pdf_buffer:
            return ResponseUtil.error('诊断报告不存在', code=404)
        
        return send_file(
            pdf_buffer,
            as_attachment=True,
            download_name=f'diagnosis_report_{diagnosis_id}.pdf',
            mimetype='application/pdf'
        )
        
    except Exception as e:
        return ResponseUtil.error(f'下载报告失败: {str(e)}', code=500)

@diagnosis_bp.route('/api/diagnosis/history', methods=['GET'])
def get_diagnosis_history():
    """
    获取诊断历史记录
    """
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)
        patient_name = request.args.get('patient_name', '').strip()
        
        result = DiagnosisService.get_diagnosis_history(
            page=page,
            per_page=per_page,
            patient_name=patient_name
        )
        
        return ResponseUtil.success(
            message='查询成功',
            data=result
        )
        
    except Exception as e:
        return ResponseUtil.error(f'查询历史记录失败: {str(e)}', code=500)

@diagnosis_bp.route('/api/diagnosis/detail/<diagnosis_id>', methods=['GET'])
def get_diagnosis_detail(diagnosis_id):
    """
    获取诊断详情
    """
    try:
        detail = DiagnosisService.get_diagnosis_detail(diagnosis_id)
        
        if not detail:
            return ResponseUtil.error('诊断记录不存在', code=404)
        
        return ResponseUtil.success(
            message='查询成功',
            data=detail
        )
        
    except Exception as e:
        return ResponseUtil.error(f'查询诊断详情失败: {str(e)}', code=500)
```

### 2. 服务层 `app/services/diagnosis_service.py`

```python
import os
import uuid
import base64
import io
from datetime import datetime
from flask import current_app
import requests
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from app.services.oss_service import OSSService
from app.utils.file_util import FileUtil

class DiagnosisService:
    
    # 内存中存储诊断记录（生产环境应使用数据库）
    _diagnosis_records = {}
    
    @classmethod
    def process_diagnosis(cls, image_file, clinical_info, patient_info):
        """
        处理诊断请求
        """
        try:
            # 生成诊断ID
            diagnosis_id = f"diag_{uuid.uuid4().hex[:12]}"
            
            # 验证文件类型
            if not FileUtil.allowed_file(image_file.filename, {'png', 'jpg', 'jpeg', 'bmp'}):
                raise ValueError("不支持的文件类型")
            
            # 调用大模型API生成诊断报告
            diagnosis_report = cls._call_llm_api(image_file, clinical_info)
            
            # 生成PDF报告
            pdf_buffer = cls._create_pdf_report(clinical_info, diagnosis_report, patient_info)
            
            # 上传PDF到OSS（可选）
            pdf_url = None
            if current_app.config.get('ENABLE_OSS'):
                pdf_url = OSSService.upload_pdf(pdf_buffer, f"diagnosis/{diagnosis_id}.pdf")
            
            # 保存诊断记录
            diagnosis_record = {
                'diagnosis_id': diagnosis_id,
                'patient_info': patient_info,
                'clinical_info': clinical_info,
                'diagnosis_report': diagnosis_report,
                'pdf_url': pdf_url,
                'timestamp': datetime.utcnow().isoformat(),
                'status': 'completed'
            }
            cls._diagnosis_records[diagnosis_id] = diagnosis_record
            
            return {
                'diagnosis_id': diagnosis_id,
                'diagnosis_report': diagnosis_report,
                'timestamp': diagnosis_record['timestamp'],
                'pdf_url': f"/api/diagnosis/download/{diagnosis_id}"
            }
            
        except Exception as e:
            raise Exception(f"诊断处理失败: {str(e)}")
    
    @classmethod
    def _call_llm_api(cls, image_file, clinical_info):
        """
        调用大模型API
        """
        try:
            # 编码图片为base64
            image_data = image_file.read()
            base64_image = base64.b64encode(image_data).decode('utf-8')
            
            # 构建提示词（可根据实际需求调整）
            prompt = f"""
            你是一位专业的放射科医生，请根据以下肺结核影像和临床信息进行分析：

            临床信息：{clinical_info}

            请提供专业的诊断报告，包括以下部分：
            1. 影像描述
            2. 影像学表现  
            3. 诊断意见
            4. 建议

            请用专业、准确的医学语言进行描述。
            """
            
            # 配置大模型API（这里以通义千问为例）
            api_config = current_app.config.get('LLM_API_CONFIG', {})
            
            payload = {
                "model": api_config.get('model', 'qwen-max'),
                "input": {
                    "messages": [
                        {
                            "role": "user",
                            "content": [
                                {
                                    "image": f"data:image/jpeg;base64,{base64_image}"
                                },
                                {
                                    "text": prompt
                                }
                            ]
                        }
                    ]
                },
                "parameters": {
                    "max_tokens": 2000,
                    "temperature": 0.1
                }
            }
            
            headers = {
                'Authorization': f'Bearer {api_config.get("api_key")}',
                'Content-Type': 'application/json'
            }
            
            response = requests.post(
                api_config.get('api_url'),
                json=payload,
                headers=headers,
                timeout=60
            )
            response.raise_for_status()
            
            result = response.json()
            if 'output' in result and 'text' in result['output']:
                return result['output']['text']
            else:
                return "模型返回格式异常，无法生成诊断报告。"
                
        except requests.exceptions.RequestException as e:
            raise Exception(f"调用大模型API失败: {str(e)}")
        except Exception as e:
            raise Exception(f"处理模型响应时出错: {str(e)}")
    
    @classmethod
    def _create_pdf_report(cls, clinical_info, diagnosis_report, patient_info):
        """
        生成PDF诊断报告
        """
        try:
            buffer = io.BytesIO()
            doc = SimpleDocTemplate(buffer, pagesize=A4)
            
            # 样式定义
            styles = getSampleStyleSheet()
            styles.add(ParagraphStyle(
                name='Title',
                parent=styles['Heading1'],
                fontSize=16,
                textColor=colors.darkblue,
                spaceAfter=30,
            ))
            styles.add(ParagraphStyle(
                name='BodyText',
                parent=styles['BodyText'],
                fontSize=10,
                spaceAfter=12,
            ))
            
            # 构建内容
            story = []
            
            # 标题
            title = Paragraph("肺结核影像诊断报告", styles['Title'])
            story.append(title)
            story.append(Spacer(1, 0.2*inch))
            
            # 患者信息表格
            if any(patient_info.values()):
                patient_data = [
                    ['患者姓名', patient_info.get('name', '未提供')],
                    ['性别', patient_info.get('gender', '未提供')],
                    ['年龄', patient_info.get('age', '未提供')],
                    ['病历号', patient_info.get('medical_record_id', '未提供')],
                    ['报告日期', datetime.now().strftime('%Y年%m月%d日')]
                ]
                
                patient_table = Table(patient_data, colWidths=[1.5*inch, 3*inch])
                patient_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.lightblue),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, -1), 10),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
                story.append(patient_table)
                story.append(Spacer(1, 0.3*inch))
            
            # 临床信息
            clinical_heading = Paragraph("临床信息", styles['Heading2'])
            story.append(clinical_heading)
            clinical_content = Paragraph(clinical_info, styles['BodyText'])
            story.append(clinical_content)
            story.append(Spacer(1, 0.2*inch))
            
            # 诊断报告
            diagnosis_heading = Paragraph("诊断报告", styles['Heading2'])
            story.append(diagnosis_heading)
            formatted_report = diagnosis_report.replace('\n', '<br/>')
            diagnosis_content = Paragraph(formatted_report, styles['BodyText'])
            story.append(diagnosis_content)
            
            # 构建PDF
            doc.build(story)
            buffer.seek(0)
            return buffer
            
        except Exception as e:
            raise Exception(f"生成PDF报告失败: {str(e)}")
    
    @classmethod
    def get_diagnosis_pdf(cls, diagnosis_id):
        """
        获取诊断PDF报告
        """
        try:
            # 从存储中获取诊断记录
            record = cls._diagnosis_records.get(diagnosis_id)
            if not record:
                return None
            
            # 重新生成PDF（或从OSS下载）
            pdf_buffer = cls._create_pdf_report(
                record['clinical_info'],
                record['diagnosis_report'],
                record['patient_info']
            )
            
            return pdf_buffer
            
        except Exception as e:
            raise Exception(f"获取PDF报告失败: {str(e)}")
    
    @classmethod
    def get_diagnosis_history(cls, page=1, per_page=10, patient_name=None):
        """
        获取诊断历史记录
        """
        try:
            # 过滤记录
            records = list(cls._diagnosis_records.values())
            
            if patient_name:
                records = [r for r in records if r['patient_info'].get('name') == patient_name]
            
            # 排序
            records.sort(key=lambda x: x['timestamp'], reverse=True)
            
            # 分页
            total = len(records)
            start_idx = (page - 1) * per_page
            end_idx = start_idx + per_page
            paginated_records = records[start_idx:end_idx]
            
            # 构建返回数据
            diagnosis_list = []
            for record in paginated_records:
                diagnosis_list.append({
                    'diagnosis_id': record['diagnosis_id'],
                    'patient_name': record['patient_info'].get('name', ''),
                    'clinical_info': record['clinical_info'][:100] + '...' if len(record['clinical_info']) > 100 else record['clinical_info'],
                    'timestamp': record['timestamp'],
                    'status': record['status']
                })
            
            return {
                'diagnosis_list': diagnosis_list,
                'pagination': {
                    'page': page,
                    'per_page': per_page,
                    'total': total,
                    'pages': (total + per_page - 1) // per_page
                }
            }
            
        except Exception as e:
            raise Exception(f"获取诊断历史失败: {str(e)}")
    
    @classmethod
    def get_diagnosis_detail(cls, diagnosis_id):
        """
        获取诊断详情
        """
        try:
            record = cls._diagnosis_records.get(diagnosis_id)
            if not record:
                return None
            
            return {
                'diagnosis_id': record['diagnosis_id'],
                'patient_info': record['patient_info'],
                'clinical_info': record['clinical_info'],
                'diagnosis_report': record['diagnosis_report'],
                'timestamp': record['timestamp'],
                'status': record['status'],
                'pdf_url': f"/api/diagnosis/download/{diagnosis_id}"
            }
            
        except Exception as e:
            raise Exception(f"获取诊断详情失败: {str(e)}")
```

### 3. 工具类更新 `app/utils/__init__.py`

```python
# 在现有的ResponseUtil中添加诊断相关方法
class ResponseUtil:
    
    @staticmethod
    def success(message="操作成功", data=None, code=200):
        """成功响应"""
        response = {
            "code": code,
            "message": message
        }
        if data is not None:
            response["data"] = data
        return jsonify(response), code
    
    @staticmethod
    def error(message="操作失败", code=400, data=None):
        """错误响应"""
        response = {
            "code": code,
            "message": message
        }
        if data is not None:
            response["data"] = data
        return jsonify(response), code

# 文件工具类
class FileUtil:
    
    @staticmethod
    def allowed_file(filename, allowed_extensions):
        """检查文件类型"""
        return '.' in filename and \
               filename.rsplit('.', 1)[1].lower() in allowed_extensions
```

### 4. 配置更新 `app/config.py`

```python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    """基础配置"""
    SECRET_KEY = os.environ.get('SECRET_KEY', 'dev-secret-key')
    
    # 大模型API配置
    LLM_API_CONFIG = {
        'api_url': os.environ.get('LLM_API_URL', 'https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation'),
        'api_key': os.environ.get('LLM_API_KEY', 'your-api-key'),
        'model': os.environ.get('LLM_MODEL', 'qwen-max')
    }
    
    # OSS配置
    OSS_CONFIG = {
        'access_key_id': os.environ.get('OSS_ACCESS_KEY_ID'),
        'access_key_secret': os.environ.get('OSS_ACCESS_KEY_SECRET'),
        'endpoint': os.environ.get('OSS_ENDPOINT'),
        'bucket_name': os.environ.get('OSS_BUCKET_NAME')
    }
    
    ENABLE_OSS = os.environ.get('ENABLE_OSS', 'false').lower() == 'true'

class DevelopmentConfig(Config):
    """开发环境配置"""
    DEBUG = True

class ProductionConfig(Config):
    """生产环境配置"""
    DEBUG = False
```

### 5. 环境变量配置 `.env`

```env
# 大模型API配置
LLM_API_URL=https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation
LLM_API_KEY=your-actual-api-key-here
LLM_MODEL=qwen-max

# OSS配置（可选）
ENABLE_OSS=false
OSS_ACCESS_KEY_ID=your-access-key-id
OSS_ACCESS_KEY_SECRET=your-access-key-secret
OSS_ENDPOINT=your-oss-endpoint
OSS_BUCKET_NAME=your-bucket-name

# 应用配置
SECRET_KEY=your-secret-key
```

### 6. 应用工厂更新 `app/__init__.py`

```python
from flask import Flask
from app.config import DevelopmentConfig
from app.routes import federated_data_routes, model_routes, diagnosis_routes

def create_app(config_class=DevelopmentConfig):
    app = Flask(__name__)
    app.config.from_object(config_class)
    
    # 注册蓝图
    app.register_blueprint(federated_data_routes.federated_data_bp)
    app.register_blueprint(model_routes.model_bp)
    app.register_blueprint(diagnosis_routes.diagnosis_bp)  # 新增诊断蓝图
    
    return app
```

## 使用说明

1. **配置环境变量**: 在 `.env` 文件中配置大模型API密钥
2. **安装依赖**: 添加 `requests` 和 `reportlab` 到依赖列表
3. **启动应用**: 运行 `python run.py`
4. **调用接口**: 使用POST请求提交诊断，GET请求下载报告

这个设计完全集成到您现有的Flask架构中，保持了代码的一致性和可维护性。